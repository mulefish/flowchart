<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Flowchart Canvas - Full Functionality</title>
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
      }
      /* Flexbox container to hold form and right panel side by side */
      #main-container {
        display: flex;
        flex-direction: row;
      }
      #form-container {
        width: 50%;
        padding: 20px;
        box-sizing: border-box;
      }
      #right-panel {
        background-color: lightblue;
        width: 50%;
        padding: 20px;
        box-sizing: border-box;
      }
      canvas {
        display: block;
        background-color: #e0e0e0;
        width: 100vw;
        height: 600px;
      }
    </style>
  </head>
  <body>
    <canvas id="flowchartCanvas"></canvas>

    <!-- Flexbox wrapper for side-by-side layout -->
    <div id="main-container">
      <div id="form-container">
        <h3>STEP 1: Add a node. Give it a key and a human facing string. Drag it somewhere</h3>
        <form id="nodeForm">
          <label for="nodeKey">Key:</label>
          <input type="text" id="nodeKey" required />
          <label for="nodeHuman">Label:</label>
          <input type="text" id="nodeHuman" required />
          <label for="nodeColor">Color:</label>
          <input type="color" id="nodeColor" value="#ffffff" />
          <label for="nodeType">Type:</label>
          <select id="nodeType">
            <option value="box">Box</option>
            <option value="diamond">Diamond</option>
            <!-- Optionally you could add circle here too -->
          </select>
          <button type="submit">Add Node</button>
        </form>

        <h3>STEP2: Add a Connection to 2 nodes by their keys</h3>
        <form id="connectionForm">
          <label for="fromNode">From:</label>
          <input type="text" id="fromNode" required />
          <label for="toNode">To:</label>
          <input type="text" id="toNode" required />
          <label for="lineType">Line Type:</label>
          <select id="lineType">
            <option value="normal">Normal (Black)</option>
            <option value="yes">Yes (Green)</option>
            <option value="no">No (Red)</option>
          </select>
          <button type="submit">Add Connection</button>
        </form>

        <h3>STEP3: Add a circle to a Connection, by their keys, and give the circle a key/value ( dropdown for color )</h3>
        <form id="circleForm">
          <label for="fromNode2">From (Node Key):</label>
          <input type="text" id="fromNode2" required />

          <label for="circleKey">Circle Key:</label>
          <input type="text" id="circleKey" required />

          <label for="toNode2">To (Node Key):</label>
          <input type="text" id="toNode2" required />

          <label for="circleChoice">Choice:</label>
          <select id="circleChoice">
            <option value="none">NONE</option>
            <option value="yes">YES</option>
            <option value="no">NO</option>
          </select>

          <button type="submit">Insert CIRCLE</button>
        </form>

        <h3>Selected Node Details</h3>
        <div id="selectedNodeDetails">
          <strong>Key:</strong> <span id="nodeKeyDetail">None</span><br />
          <strong>Label:</strong> <span id="nodeLabelDetail">None</span><br />
          <strong>Color:</strong> <span id="nodeColorDetail">None</span><br />
          <strong>Type:</strong> <span id="nodeTypeDetail">None</span><br />
          <strong>Position:</strong>
          <span id="nodePositionDetail">(N/A, N/A)</span><br />
          <button id="deleteNode" disabled>Delete Selected Node</button>
        </div>
        <br />

        <button id="saveGraph">
          STEP4: Emit graph, as json, to textarea
        </button>

          <br/> 
          <hr/>
          extras:         
        <button onclick="scaleNodesToFit()">Rescale to fit your screen!</button>
        <button onclick="makePiniaStore()">Emit TS of the graph to textarea (for a Pinia store)</button>

      </div>

      <!-- ✅ New Right-Side Div -->
      <div id="right-panel">
      <textarea id="graphJson" rows="50" cols="120"></textarea>
      
      </div>
    </div>

    <script>
      
function generatePiniaStoreData(graphData) {
  const store = {
    lastPage: null,
    currentPath: null,
    diamonds: {},
    squares: {},
    dependencies: {}
  };

  // Build an index of nodes by their letter.
  const nodeMap = new Map();
  graphData.nodes.forEach(node => {
    nodeMap.set(node.letter, node);
    // Populate diamonds and squares with default status "NILL"
    if (node.type === "diamond") {
      store.diamonds[node.letter.toLowerCase()] = "NILL";
    } else if (node.type === "box") {
      store.squares[node.letter.toLowerCase()] = "NILL";
    }
  });

  // Helper: map a circle's dropdown choice to an expected value.
  // If the choice is "yes", "no", or "none", return it in uppercase;
  // otherwise, return "NILL".
  function mapCircleChoice(choice) {
    if (choice) {
      const lower = choice.toLowerCase();
      if (lower === "yes") return "YES";
      if (lower === "no") return "NO";
      if (lower === "none") return "NONE";
    }
    return "NILL";
  }

  // Process connections to build dependencies.
  graphData.connections.forEach(conn => {
    const fromNode = nodeMap.get(conn.from);
    const toNode = nodeMap.get(conn.to);
    if (!fromNode || !toNode) return;

    // Only process dependencies starting from a box node.
    if (fromNode.type === "box") {
      if (toNode.type === "box") {
        // Direct box→box connection: expected is "NILL"
        const parentKey = fromNode.letter.toLowerCase();
        const childKey = toNode.letter.toLowerCase();
        if (!store.dependencies[parentKey]) {
          store.dependencies[parentKey] = { children: [] };
        }
        store.dependencies[parentKey].children.push({
          url: childKey,
          expected: "NILL",
          preconditions: []
        });
      } else if (toNode.type === "circle") {
        // For a circle node, look for its subsequent connection to a box.
        graphData.connections.forEach(conn2 => {
          if (conn2.from === toNode.letter) {
            const childNode = nodeMap.get(conn2.to);
            if (childNode && childNode.type === "box") {
              const parentKey = fromNode.letter.toLowerCase();
              const childKey = childNode.letter.toLowerCase();
              if (!store.dependencies[parentKey]) {
                store.dependencies[parentKey] = { children: [] };
              }
              const expectedVal = mapCircleChoice(toNode.choice);
              // Create a precondition based on the circle's value.
              const precondition = {
                category: "diamonds",
                key: toNode.letter.toLowerCase(),
                expected: expectedVal
              };
              store.dependencies[parentKey].children.push({
                url: childKey,
                expected: expectedVal,
                preconditions: [precondition]
              });
            }
          }
        });
      }
    }
  });

  return store;
}


    </script>

    <script src="graph.js"></script>
  </body>
</html>
