<!DOCTYPE html>
<html lang="en">
<head>
<script>
    window.onerror = function(msg, url, line, col, error) {
        let  extra = !col ? '' : '\ncolumn: ' + col;
        extra += !error ? '' : '\nerror: ' + error;
        document.getElementById("errors").innerHTML = "Error: " + msg + "<br/>line: " + line + "<br/>" + extra;
    }
</script>
    <meta charset="UTF-8" />
    <title>Flowchart Canvas - Full Functionality</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
        }

        #main-container {
            display: flex;
            flex-direction: row;
        }

        #left-container {
            /* width: 65%; */            
            background-color: lightgray;
            padding: 20px;
            box-sizing: border-box;
        }

        #right-panel {
            /* width: 35%; */
            padding: 20px;
            box-sizing: border-box;
        }

        canvas {
            display: block;
            background-color: #e0e0e0;
            width: 100vw;
            height: 600px;
        }

        #horizontal {
            display: flex;
            flex-direction: row;
            gap: 20px;
        }
        input {
            width:200px;
            background-color: #ffffff;
            font-size: 16px;
        }
        .highlight { 
            background-color: yellow;
        }
    </style>
</head>
<body>
    <canvas id="flowchartCanvas"></canvas>

    <div id="main-container">
        <div id="left-container">
            <div id="horizontal">
                <table border="1">
                    <tr><td><input type="text" id="nodeKey" required placeholder="key"
                        onmouseout="copyOver('nodeKey', 'nodeHuman')"
                        onblur="copyOver('nodeKey', 'nodeHuman')" /></td></tr>
                    <tr><td><input type="text" id="nodeHuman" required placeholder="human" /></td></tr>
                    <tr><td><button class="highlight" onclick="addNode()">add node</button></td></tr>
                    <tr><td><input type="color" id="nodeColor" value="#ffffff" /></td></tr>
                    <tr><td>
                        <select id="nodeType">
                            <option value="box">Box</option>
                            <option value="diamond">Diamond</option>
                            <option value="circle">Circle</option>
                        </select>
                    </td></tr>
                </table>

                <table border="1">
                    <tr><td><input type="text" id="fromNode" required placeholder="fromNode" /></td></tr>
                    <tr><td><input type="text" id="toNode" required placeholder="toNode" /></td></tr>
                    <tr><td><button class="highlight" onclick="addConnection_step0()">add connection</button></td></tr>
                    <tr><td>
                        <select id="lineType">
                            <option value="normal">Normal (Black)</option>
                            <option value="yes">Yes (Green)</option>
                            <option value="no">No (Red)</option>
                        </select>
                    </td></tr>
                </table>

                <table border="1">
                    <tr><td><input type="text" id="circleKey" required placeholder="circleKey" /></td></tr>
                    <tr><td><input type="text" id="ancestor" required placeholder="ancestor" /></td></tr>
                    <tr><td><input type="text" id="fromNode2" required placeholder="fromNode2" /></td></tr>
                    <tr><td><input type="text" id="toNode2" required placeholder="toNode2" /></td></tr>
                    <tr><td>
                        <select id="circleChoice">
                            <option value="none">None</option>
                            <option value="yes">Yes</option>
                            <option value="no">No</option>
                        </select>
                    </td></tr>
                    <tr><td><button class="highlight" onclick="addDecisionPoint()">add decision</button></td></tr>
                </table>
            </div>
            <hr/>
            <table border="1">
                    <tr><td><input type="text" id="nodeKeyDetail" placeholder="letter"></span></td></tr>
                    <tr><td><input type="text" id="nodeLabelDetail" placeholder="human"></span></td></tr>
                    <tr><td><input type="text" id="nodeColorDetail" placeholder="color"></span></td></tr>
                    <tr><td><button id="deleteNode" >delete</button></td></tr>
                    <tr><td><button onclick="scaleNodesToFit()" >scale</button></td></tr>
                    <tr><td><button onClick="emitGraph()">emit graph</button></td></tr>
                    <tr><td><button class="highlight" onClick="emitPinia()">emit pinia</button></td></tr>
            </table>
            <hr/>
            <div id="errors"></div>
        </div>

        <div id="right-panel">
            <textarea id="graphJson" rows="50" cols="160" spellcheck="false"></textarea>
        </div>
    </div>

<script src="graph.js"></script>
<script>
main("initialData.json");



function emitPinia() {
  const nodes = [];
  graph.forEach((shape) => {
    nodes.push({
      letter: shape.letter,
      human: shape.human,
      type: shape.type,
    });
  });

  const graphData = { nodes, connections };

  const theData = downstreamCirclesBetweenBoxes(graphData);
  document.getElementById("graphJson").value = JSON.stringify(theData, null, 2 )
}
function downstreamCirclesBetweenBoxes(graph) {
  // 1) Create a lookup from letter -> node object
  const nodeByLetter = {};
  graph.nodes.forEach((node) => {
    nodeByLetter[node.letter] = node;
  });

  // 2) Build a forward adjacency list,
  //    but store objects: { next: toNodeLetter, edgeType: connection.type }.
  const adjacency = {};
  graph.nodes.forEach((node) => {
    adjacency[node.letter] = [];
  });
  graph.connections.forEach(({ from, to, type: edgeType }) => {
    adjacency[from].push({ next: to, edgeType });
  });

  // 3) Gather all "box" nodes. We'll add .downstream to store results.
  const boxes = {};
  graph.nodes.forEach((node) => {
    if (node.type === "box") {
      boxes[node.letter] = {
        ...node,
        // We'll have objects like:
        //   { box: 'downstreamBoxLetter', circles: [ { letter, choice }, ... ] }
        downstream: [],
      };
    }
  });

  // Helper function to merge two sets of circle objects
  // we track circles in a Map keyed by circle letter -> { letter, choice }
  function unionCircleMaps(mapA, mapB) {
    const result = new Map(mapA); // clone
    for (const [letter, circleObj] of mapB.entries()) {
      result.set(letter, circleObj);
    }
    return result;
  }

  // 4) For each box, we do a DFS down the graph to find the *next* box(es),
  //    collecting any circle nodes encountered along each path.
  function collectDownstreamBoxesAndCircles(startBoxLetter) {
    // We'll store a map: boxLetter -> Map(circleLetter -> { letter, choice })
    const boxToCirclesMap = new Map();

    // DFS function carries a Map of circles so far (by letter), 
    // and merges as it goes deeper.
    function dfs(currentLetter, circlesSoFar, visited) {
      const currentNode = nodeByLetter[currentLetter];

      // Explore all children in adjacency
      for (const { next: childLetter, edgeType } of adjacency[currentLetter]) {
        if (!visited.has(childLetter)) {
          visited.add(childLetter);

          // Copy the circlesSoFar map so each path can diverge
          let newCircles = new Map(circlesSoFar);

          // If the child is a circle, we add it with its "choice" = edgeType
          const childNode = nodeByLetter[childLetter];
          if (childNode.type === "circle") {
            // Possibly only store if edgeType is "yes" or "no"?
            // For now, we store the raw edgeType:
            newCircles.set(childLetter, {
              letter: childLetter,
              choice: edgeType, // e.g. "yes", "no", "normal", etc.
            });
          }

          // If the child is a *different* box, we've reached the next box
          if (childNode.type === "box" && childLetter !== startBoxLetter) {
            // Merge these circles into whatever we had for that box
            const existingMap = boxToCirclesMap.get(childLetter) || new Map();
            const combined = unionCircleMaps(existingMap, newCircles);
            boxToCirclesMap.set(childLetter, combined);
            // Stop going deeper from here
          } else {
            // Keep DFSing
            dfs(childLetter, newCircles, visited);
          }
        }
      }
    }

    const visited = new Set([startBoxLetter]);
    dfs(startBoxLetter, new Map(), visited);

    // Convert the boxToCirclesMap into an array:
    //   [ { box: "someBoxLetter", circles: [ { letter, choice }, ... ] } ... ]
    return [...boxToCirclesMap.entries()].map(([downstreamBox, circlesMap]) => ({
      box: downstreamBox,
      circles: [...circlesMap.values()],
    }));
  }

  // 5) Populate each boxâ€™s .downstream property
  for (const boxLetter in boxes) {
    boxes[boxLetter].downstream = collectDownstreamBoxesAndCircles(boxLetter);
  }

  return boxes;
}

// Example usage:
function testDownstream() {
  const results = downstreamCirclesBetweenBoxes(bigBallOfJson);
  console.dir(results["attributes"], { depth: null });
  /*
    You might see something like:
    {
      letter: 'attributes',
      ...
      downstream: [
        {
          box: 'address',
          circles: [ { letter: 'is_match_good_no', choice: 'no' }, ... ]
        },
        ...
      ]
    }
  */
}



function getDependencies() {
  const raw = downstreamCirclesBetweenBoxes(bigBallOfJson);
  const dependencies = {} 
  for ( let k in raw ) {
    const obj = convertShape( raw[k].letter,  raw[k].downstream)
    dependencies[k]=obj
  }
  const squares = {}
  const diamonds = {}
  for ( let i in bigBallOfJson.nodes ) { 
    const letter = bigBallOfJson.nodes[i].letter
    const type = bigBallOfJson.nodes[i].type
    if ( type === "circle" ) { 
      diamonds[letter]="NILL"
    } else {
      squares[letter]="NILL"
    }
  }
  return {diamonds, squares, dependencies}
 
}

function convertShape(letter, downstream) {
  let obj = {} 
  obj["url"] = letter 
  obj["preconditions"] = []
  let neededThings = [] 
  downstream.forEach((obj2)=>{
    const precognition = []
    obj2.circles.forEach((thing)=> { 
     const x = {
        "category":"diamonds",
        "key":thing.letter,
        "expected": thing.choice     
      }
      obj["preconditions"].push(x)
    })
  })
  return obj
}





</script>
</body>
</html>
