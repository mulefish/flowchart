<!DOCTYPE html>
<html lang="en">
<head>
<script>
    window.onerror = function(msg, url, line, col, error) {
        let  extra = !col ? '' : '\ncolumn: ' + col;
        extra += !error ? '' : '\nerror: ' + error;
        document.getElementById("errors").innerHTML = "Error: " + msg + "<br/>line: " + line + "<br/>" + extra;
    }
</script>
    <meta charset="UTF-8" />
    <title>Flowchart Canvas - Full Functionality</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
        }

        #main-container {
            display: flex;
            flex-direction: row;
        }

        #left-container {
            /* width: 65%; */            
            background-color: lightgray;
            padding: 20px;
            box-sizing: border-box;
        }

        #right-panel {
            /* width: 35%; */
            padding: 20px;
            box-sizing: border-box;
        }

        canvas {
            display: block;
            background-color: #e0e0e0;
            width: 100vw;
            height: 600px;
        }

        #horizontal {
            display: flex;
            flex-direction: row;
            gap: 20px;
        }
        input {
            width:200px;
            background-color: #ffffff;
            font-size: 16px;
        }
        .highlight { 
            background-color: yellow;
        }
    </style>
</head>
<body>
    <canvas id="flowchartCanvas"></canvas>

    <div id="main-container">
        <div id="left-container">
            <div id="horizontal">
                <table border="1">
                    <tr><td><input type="text" id="nodeKey" required placeholder="key"
                        onmouseout="copyOver('nodeKey', 'nodeHuman')"
                        onblur="copyOver('nodeKey', 'nodeHuman')" /></td></tr>
                    <tr><td><input type="text" id="nodeHuman" required placeholder="human" /></td></tr>
                    <tr><td><button class="highlight" onclick="addNode()">add node</button></td></tr>
                    <tr><td><input type="color" id="nodeColor" value="#ffffff" /></td></tr>
                    <tr><td>
                        <select id="nodeType">
                            <option value="box">Box</option>
                            <option value="diamond">Diamond</option>
                            <option value="circle">Circle</option>
                        </select>
                    </td></tr>
                </table>

                <table border="1">
                    <tr><td><input type="text" id="fromNode" required placeholder="fromNode" /></td></tr>
                    <tr><td><input type="text" id="toNode" required placeholder="toNode" /></td></tr>
                    <tr><td><button class="highlight" onclick="addConnection_step0()">add connection</button></td></tr>
                    <tr><td>
                        <select id="lineType">
                            <option value="normal">Normal (Black)</option>
                            <option value="yes">Yes (Green)</option>
                            <option value="no">No (Red)</option>
                        </select>
                    </td></tr>
                </table>

                <table border="1">
                    <tr><td><input type="text" id="circleKey" required placeholder="circleKey" /></td></tr>
                    <tr><td><input type="text" id="ancestor" required placeholder="ancestor" /></td></tr>
                    <tr><td><input type="text" id="fromNode2" required placeholder="fromNode2" /></td></tr>
                    <tr><td><input type="text" id="toNode2" required placeholder="toNode2" /></td></tr>
                    <tr><td>
                        <select id="circleChoice">
                            <option value="none">None</option>
                            <option value="yes">Yes</option>
                            <option value="no">No</option>
                        </select>
                    </td></tr>
                    <tr><td><button class="highlight" onclick="addDecisionPoint()">add decision</button></td></tr>
                </table>
            </div>
            <hr/>
            <table border="1">
                    <tr><td><input type="text" id="nodeKeyDetail" placeholder="letter"></span></td></tr>
                    <tr><td><input type="text" id="nodeLabelDetail" placeholder="human"></span></td></tr>
                    <tr><td><input type="text" id="nodeColorDetail" placeholder="color"></span></td></tr>
                    <tr><td><button id="deleteNode" >delete</button></td></tr>
                    <tr><td><button onclick="scaleNodesToFit()" >scale</button></td></tr>
                    <tr><td><button onClick="emitGraph()">emit graph</button></td></tr>
                    <tr><td><button class="highlight" onClick="emitPinia()">emit pinia</button></td></tr>
            </table>
            <hr/>
            <div id="errors"></div>
        </div>

        <div id="right-panel">
            <textarea id="graphJson" rows="50" cols="160" spellcheck="false"></textarea>
        </div>
    </div>

<script src="complete.js"></script>
<script>
main("complete.json");



function emitPinia() {
  const nodes = [];
  graph.forEach((shape) => {
    nodes.push({
      letter: shape.letter,
    //   x: shape.x,
    //   y: shape.y,
      human: shape.human,
    //   color: shape.color,
      type: shape.type,
    });
  });

  const graphData = { nodes, connections };


  let result =  createDependencyGraph( graphData)
    document.getElementById("graphJson").value = " THIS IS FOR A PINIA STORE\n" +  JSON.stringify(
    result,
    null,
    2
  );

}

function createDependencyGraph(graph) {
  // 1) Map each letter -> node object for quick type lookups
  const nodeByLetter = {};
  graph.nodes.forEach((node) => {
    nodeByLetter[node.letter] = node;
  });

  // 2) Build a forward adjacency list: adjacency[from] = [to1, to2...]
  const adjacency = {};
  graph.nodes.forEach((node) => {
    adjacency[node.letter] = [];
  });
  graph.connections.forEach(({ from, to }) => {
    adjacency[from].push(to);
  });

  // 3) Identify all "box" nodes and prepare a results structure
  //    where we'll store, for each box, the "downstream" boxes and circles en route.
  const boxes = {};
  graph.nodes.forEach((node) => {
    if (node.type === "box" || node.type === "diamond") {
      boxes[node.letter] = {
        ...node,
        // We'll populate this with an array of objects, each like:
        // { box: "someBoxLetter", circles: ["circle1", "circle2", ...] }
        downstream: [],
      };
    }
  });

  // 4) Define a DFS function that:
  //    - Carries along a Set of circles encountered so far
  //    - If it reaches a new box, it records that box & circles, then stops that path
  //    - Otherwise continues exploring
  function collectDownstreamBoxesAndCircles(startBoxLetter) {
    // We'll store: Map< boxLetter, Set<circleLetters> >
    // so if multiple paths lead to the same box, we can combine circles.
    const boxToCirclesMap = new Map();

    function dfs(currentLetter, circlesSoFar, visited) {
      const currentNode = nodeByLetter[currentLetter];

      // If this node is a circle, add it to our circlesSoFar
      if (currentNode.type === "circle") {
        circlesSoFar = new Set([...circlesSoFar, currentLetter]);
      }

      // If this node is a *different* box (not the start), we've reached a "next" box.
      if ( ( currentNode.type === "box" || currentNode.type === "diamond") && currentLetter !== startBoxLetter) {
        // Merge circlesSoFar into any existing set for this box
        const prev = boxToCirclesMap.get(currentLetter) || new Set();
        boxToCirclesMap.set(
          currentLetter,
          new Set([...prev, ...circlesSoFar])
        );
        // Stop going deeper down from this box
        return;
      }

      // Otherwise, keep going
      for (const child of adjacency[currentLetter]) {
        if (!visited.has(child)) {
          visited.add(child);
          dfs(child, circlesSoFar, visited);
        }
      }
    }

    const visited = new Set([startBoxLetter]);
    dfs(startBoxLetter, new Set(), visited);

    // Convert boxToCirclesMap to an array of { box: boxLetter, circles: [ ... ] }
    return [...boxToCirclesMap.entries()].map(([boxLetter, circleSet]) => ({
      box: boxLetter,
      circles: [...circleSet],
    }));
  }

  // 5) Run this for *every* box
  for (const boxLetter in boxes) {
    boxes[boxLetter].downstream = collectDownstreamBoxesAndCircles(boxLetter);
  }

  return boxes;
}


</script>
</body>
</html>
